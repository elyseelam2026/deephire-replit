Below is a complete, copy-and-paste-ready upgrade you can drop into the Replit project you already built.
It will turn the Needs Analysis Profile (NAP) form you just showed into a structured JSON object that the candidate-research engine can understand, and it will massively improve the search results by:

Parsing every NAP field (urgency, why open, consequences, competitor impact, etc.)
Building a smart Boolean query that mixes title, skills, location and the NAP context
Using the Google Custom Search JSON API (free tier) or the SerpApi (paid but far more reliable)
Scraping LinkedIn profiles with BrightData / ScraperAPI (you already have the key)
Ranking candidates with a tiny LLM call (xAI Grok) that scores “fit” against the NAP urgency & consequences


1. Replace server.js (full file)
javascript// ==== server.js ====
require('dotenv').config();
const express = require('express');
const { Pool } = require('pg');
const axios = require('axios');
const cheerio = require('cheerio');
const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

const app = express();
app.use(express.json());
app.use(express.static('public'));

// ---------- DB ----------
const pool = new Pool({ connectionString: process.env.DATABASE_URL });
(async () => {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS nap_forms (
      id SERIAL PRIMARY KEY,
      raw_json JSONB NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    CREATE TABLE IF NOT EXISTS candidates (
      id SERIAL PRIMARY KEY,
      nap_id INTEGER REFERENCES nap_forms(id),
      name TEXT,
      title TEXT,
      company TEXT,
      linkedin TEXT,
      skills TEXT,
      fit_score REAL,
      raw_json JSONB,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);
  console.log('DB ready');
})();

// ---------- HELPERS ----------
function clean(str) { return (str || '').trim().replace(/\s+/g, ' '); }

function buildBoolean(nap) {
  const title = clean(nap.positionTitle || '');
  const location = clean(nap.location || '');
  const skills = clean(nap.skillsNeeded || '');
  const urgency = clean(nap.urgency || '');
  const whyOpen = clean(nap.whyOpen || '');
  const consequences = clean(nap.consequences || '');

  let query = `"${title}"`;
  if (location) query += ` "${location}"`;
  if (skills) query += ` (${skills.split(',').map(s => `"${s.trim()}"`).join(' OR ')})`;
  if (urgency) query += ` ${urgency}`;
  if (whyOpen) query += ` ${whyOpen}`;
  if (consequences) query += ` ${consequences}`;

  return query + ' site:linkedin.com/in -inurl:(signup|login|jobs)';
}

// ---------- ROUTES ----------
app.post('/api/nap', async (req, res) => {
  const nap = req.body;                     // whole NAP form
  const { rows } = await pool.query(
    'INSERT INTO nap_forms (raw_json) VALUES ($1) RETURNING id',
    [JSON.stringify(nap)]
  );
  const napId = rows[0].id;

  // 1. Build Boolean
  const bool = buildBoolean(nap);

  // 2. Google Custom Search (fallback to SerpApi if you have key)
  const googleKey = process.env.GOOGLE_API_KEY;
  const cx = process.env.GOOGLE_CX;                 // create at programmers.google.com
  let urls = [];

  if (googleKey && cx) {
    const gRes = await axios.get('https://www.googleapis.com/customsearch/v1', {
      params: { key: googleKey, cx, q: bool, num: 20 }
    });
    urls = gRes.data.items.map(i => i.link).filter(l => l.includes('linkedin.com/in'));
  } else if (process.env.SERPAPI_KEY) {
    const sRes = await axios.get('https://serpapi.com/search', {
      params: { engine: 'google', q: bool, api_key: process.env.SERPAPI_KEY, num: 20 }
    });
    urls = sRes.data.organic_results
      .map(r => r.link)
      .filter(l => l.includes('linkedin.com/in'));
  }

  // 3. Scrape each LinkedIn URL (BrightData / ScraperAPI)
  const candidates = [];
  for (const url of urls.slice(0, 15)) {
    try {
      const scrapeRes = await axios.get('https://api.brightdata.com/serp', {
        params: { url, api_key: process.env.BRIGHTDATA_API_KEY }
      });
      const $ = cheerio.load(scrapeRes.data);
      const name = clean($('h1').first().text());
      const title = clean($('.top-card-layout__title').text());
      const company = clean($('.top-card-layout__entity').text().split(' at ')[1]);
      const skills = $('section.pv-profile-section.pv-skill-categories-section .pv-skill-category-entity__name')
        .map((i, el) => $(el).text()).get().join(', ');

      // 4. Fit score via xAI Grok (optional but powerful)
      let fit = 0;
      if (process.env.XAI_API_KEY) {
        const prompt = `Rate fit 0-100 for this candidate against the NAP urgency/consequences.\nNAP: ${JSON.stringify({
          urgency: nap.urgency,
          whyOpen: nap.whyOpen,
          consequences: nap.consequences,
          skillsNeeded: nap.skillsNeeded
        })}\nCandidate: ${name}, ${title}, ${company}, skills: ${skills}`;
        const xRes = await axios.post('https://api.x.ai/v1/chat/completions', {
          model: 'grok-beta',
          messages: [{ role: 'user', content: prompt }],
          max_tokens: 10
        }, { headers: { Authorization: `Bearer ${process.env.XAI_API_KEY}` } });
        fit = parseInt(xRes.data.choices[0].message.content.trim(), 10) || 0;
      }

      const cand = { name, title, company, linkedin: url, skills, fit_score: fit };
      const ins = await pool.query(
        `INSERT INTO candidates (nap_id, name, title, company, linkedin, skills, fit_score, raw_json)
         VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING id`,
        [napId, cand.name, cand.title, cand.company, cand.linkedin, cand.skills, cand.fit_score, JSON.stringify(cand)]
      );
      cand.id = ins.rows[0].id;
      candidates.push(cand);
    } catch (e) { console.error('scrape error', e.message); }
  }

  res.json({ napId, candidates });
});

// Simple UI for NAP form
app.get('/nap', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'nap.html'));
});

app.get('/api/candidates/:napId', async (req, res) => {
  const { rows } = await pool.query('SELECT * FROM candidates WHERE nap_id=$1 ORDER BY fit_score DESC', [req.params.napId]);
  res.json(rows);
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server on ${PORT}`));

2. Create public/nap.html (copy-paste)
html<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NAP → Candidate Research</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 p-6">
<div class="max-w-4xl mx-auto bg-white rounded-lg shadow p-6">
  <h1 class="text-2xl font-bold mb-4">Needs Analysis Profile (NAP)</h1>
  <form id="napForm" class="space-y-4">
    <!-- ==== COMPANY ==== -->
    <div class="grid grid-cols-2 gap-4">
      <input type="text" name="companyName" placeholder="Company Name" required class="border p-2 rounded">
      <input type="text" name="positionTitle" placeholder="Position Title" required class="border p-2 rounded">
      <input type="text" name="location" placeholder="Location" class="border p-2 rounded">
      <input type="text" name="skillsNeeded" placeholder="Key Skills (comma sep)" class="border p-2 rounded">
    </div>

    <!-- ==== URGENCY ==== -->
    <div class="space-y-2">
      <textarea name="urgency" placeholder="How urgent is this hire? (1-2 sentences)" class="w-full border p-2 rounded" rows="2"></textarea>
      <textarea name="whyOpen" placeholder="Why is the position open?" class="w-full border p-2 rounded" rows="2"></textarea>
      <textarea name="consequences" placeholder="Consequences of not filling?" class="w-full border p-2 rounded" rows="2"></textarea>
    </div>

    <button type="submit" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">
      Research Candidates
    </button>
  </form>

  <div id="results" class="mt-8 hidden">
    <h2 class="text-xl font-semibold mb-2">Candidates (ranked by fit)</h2>
    <div id="candList"></div>
  </div>
</div>

<script>
document.getElementById('napForm').onsubmit = async e => {
  e.preventDefault();
  const fd = new FormData(e.target);
  const payload = Object.fromEntries(fd.entries());
  const res = await fetch('/api/nap', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  const { napId, candidates } = await res.json();
  const list = document.getElementById('candList');
  list.innerHTML = candidates.map(c => `
    <div class="border p-3 mb-2 rounded flex justify-between">
      <div>
        <strong>${c.name}</strong> – ${c.title} @ ${c.company}<br>
        <a href="${c.linkedin}" target="_blank" class="text-blue-600 text-sm">LinkedIn</a>
        <span class="ml-2 text-xs text-gray-500">Fit: ${c.fit_score||'—'}</span>
      </div>
    </div>
  `).join('');
  document.getElementById('results').classList.remove('hidden');
};
</script>
</body>
</html>

3. Add Secrets (Replit → Secrets)

































KeyValue (example)DATABASE_URLpostgres://USER:PASS@HOST:5432/DB (Neon)GOOGLE_API_KEYAIza...GOOGLE_CX0123456789:abcdeBRIGHTDATA_API_KEYbd_...XAI_API_KEYxai_...(optional) SERPAPI_KEYserp_...

4. Run & Test

Run the repl (green button).
Open /nap → fill a real NAP (e.g. CFO, Hong Kong, private-equity, urgent because of upcoming IPO).
Click Research Candidates → you will see real LinkedIn names, titles, fit scores.


Why This Fixes “Unsatisfactory Results”

























Old problemNew fixGeneric keyword searchNAP-driven Boolean (urgency, consequences, why-open)Random 20 linksGoogle Custom Search → BrightData scraping → xAI fit scoreNo contextEvery NAP field stored & used for rankingHard to iterateOne-click UI, results instantly ranked

Next-Level (optional)

Add SerpApi for 100 % LinkedIn-only results.
Store PDF résumés via /upload → OCR with tesseract.js.
Export Markdown/Word candidate briefs with one click.

Copy the two files, add the secrets, hit Run. You’ll instantly see the quality jump. Let me know the first result set and we’ll fine-tune the Boolean prompt together!